# 拼写纠错

首先引入编辑距离的概念，好了，懒得写了，做过力扣的应该都知道编辑距离这道很经典的动态规划题：

> 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
>
> 你可以对一个单词进行如下三种操作：
>
> 插入一个字符
> 删除一个字符
> 替换一个字符
> 示例 1:
>
> > 输入: word1 = "horse", word2 = "ros"
> > 输出: 3
> > 解释: 
> > horse -> rorse (将 'h' 替换为 'r')
> > rorse -> rose (删除 'r')
> > rose -> ros (删除 'e')
>
> 示例 2:
>
> > 输入: word1 = "intention", word2 = "execution"
> > 输出: 5
> > 解释: 
> > intention -> inention (删除 't')
> > inention -> enention (将 'i' 替换为 'e')
> > enention -> exention (将 'n' 替换为 'x')
> > exention -> exection (将 'n' 替换为 'c')
> > exection -> execution (插入 'u')

那么我们就可以知道，如果用户输入的一个词的概率很小，我们认为他可能拼写错误，就**在词典中寻找编辑距离最小的词进行替换**。

当然这可能导致较大的时间复杂度，毕竟你需要在整个词典中都搜索并计算编辑距离，这样的时间开销我们承受不住，你或许说可以使用分段分区搜索的思想，虽然这是一个可行的方法但还是有些不尽如人意。

那么我们还有另一种方法，就是**生成编辑距离为1或2的字符串并进行过滤**

生成字符串还算简单，但如何过滤是个问题。

抛开正解不谈，实际上我自己认为可以根据规则过滤，比如在24键键盘中，很容易误按出临近的一些字母，比如 o会按到p。我们可以为每一个字母设置替换概率字典，比如{o:{p:0.25,i:0.25,l:0.25,k:0.15,m:0.05 }}这样的，然后再选取在词典中出现概率较高的词得到最终的结果。

以上只是我的个人想法，在实际中还是会使用 **贝叶斯公式** 。

通俗来讲，贝叶斯就是通过先验概率得到后验概率的公式。这里以 apple为例。

正确: apple

用户1：app

用户2：appl

用户3：appl

用户4：appla

用户6: appl

我们可以从搜索记录日志中获取 用多少用户把apple写成怎样的错误单词。

假设，用户输入字符串为s,正确的字符串为c，那么可以得到：

$p(c|s)\propto p(s|c)p(c)$

p(s|c)可以理解为：对于一个正确的字符串c,有多少人写成了s 。

带入实际问题中:

 $p(s|c) = p(appl|apple)=0.5$

 $p(s|c) = p(appa|apple)=0.16$

...

p(c)是一个uni-gram，可以在词典中直接得到。